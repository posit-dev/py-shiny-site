---
title: Persistent storage & writing data
editor:
  markdown:
    wrap: sentence
lightbox:
  effect: fade
---

## Intro


* Callout connect cloud and support for secrets and persistent storage, link to docs, tehre's a talk that aleks chisolm did at conf
## When do you actually need persistent storage
* You want your application to collect and save information from your users. Example, forms.
* You need to save a result that your users generate? (ex. save a copy of report generated)

Note: What are we not talking about here: Auth. Link to any auth docs we have.

CALLOUT: Connect does both Auth and supports secrets for storage. Link to those docs.

### Example with pins and polars? (use a form, save the result)

Callout: Potential concerns with lots of parallel users or nonblocking setting, then think about switching to a database

## Working with non-database stores (ex. Google Sheets, Object Stores)
Polars + AWS S3

Callout, pins does this other stuff, plus has some reactive support

## Working with Databases

### Reading from and writing to databases

```{.python filename="setup.py"}
import polars as pl

# Don't store your creds in plain text, load them from a environment variables or a secrets manager
uri = "postgresql://postgres@localhost:5432/template1"

# Notice that this uses `read_*`. Polars cannot read the data lazily from the database, so this will load the entire query into memory.
def run_query(query):
    return pl.read_database_uri(query, uri)

```

```{.python filename="app.py"}
from shiny.express import ui, render, input, app_opts
from shiny import reactive
import polars as pl
import load_data

app_opts(debug=True)

full_query = "SELECT * FROM testapp"

with ui.sidebar():
    ui.input_text("name_input", "Enter your name:", placeholder="Your name here")
    ui.input_checkbox("checkbox", "I like checkboxes")
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50)
    ui.input_action_button("submit_button", "Submit")

# If this value is 1, our data is dirty, if it is 0, our data is clean
flag = reactive.value(0)
df = reactive.value(pl.LazyFrame(load_data.run_query(full_query)))


@reactive.effect
@reactive.event(input.submit_button)
def add_row():
    new_row = pl.DataFrame(
        {
            "name": input.name_input(),
            "checkbox": input.checkbox(),
            "favorite_number": input.slider(),
        }
    )
    new_row.write_database("testapp", load_data.uri, if_table_exists="append")

    # The table we're displaying no longer reflects the reality of the database because we just added a row, so we mark the data as dirty.

    flag.set(1)
    print("Added a new row!")


@reactive.effect
def refresh_data_if_dirty():
    if flag() == 1:
        df.set(pl.LazyFrame(load_data.run_query(full_query)))
        print("Data is dirty, refreshing...")
        flag.set(0)


@render.data_frame
def show_results():
    return render.DataGrid(df().collect())

```

Introduce the motivation for polling using the above example

### Reactive Polling

### App examples with polling
::: {.panel-tabset .panel-pills}

#### Polars + Postgres
```{.python filename="setup.py"}
import polars as pl

# Don't store your creds in plain text, load them from a environment variables or a secrets manager
uri = "postgresql://postgres@localhost:5432/template1"


# Notice that this uses `read_*`. Polars cannot read the data lazily from the database, so this will load the entire query into memory.
def run_query(query):
    return pl.read_database_uri(query, uri)


```

```{.python filename="app.py"}

from shiny.express import ui, render, input, app_opts
from shiny import reactive
import polars as pl
import setup

app_opts(debug=True)

full_query = "SELECT * FROM testapp"
starting_data = pl.LazyFrame(setup.run_query(full_query))

with ui.sidebar():
    ui.input_text("name_input", "Enter your name:", placeholder="Your name here")
    ui.input_checkbox("checkbox", "I like checkboxes")
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50)
    ui.input_action_button("submit_button", "Submit")


@reactive.effect
@reactive.event(input.submit_button)
def add_row():
    new_row = pl.DataFrame(
        {
            "name": input.name_input(),
            "checkbox": input.checkbox(),
            "favorite_number": input.slider(),
        }
    )
    new_row.write_database("testapp", setup.uri, if_table_exists="append")
    print("Added a new row!")


def num_rows():
    return load_data.run_query("SELECT COUNT(*) FROM testapp").item()


@reactive.poll(num_rows, 1)
def get_data():
    print("Checking for new data...")
    data = setup.update_data()
    return data


@render.data_frame
def show_results():
    return render.DataGrid(get_data())

```
:::





## Connecting to databases

### Example connecting with Ibis and saving to db with a form

## Deployment options

### Auth - connect callout

### SQL injection prevention
Callout near wherever we first execute SQL, be careful, diff libraries have tooling


### Connection pooling & transaction locking?

### Note on credentials? (don't use your admin creds in your app, have user creds for db, scope them narrowly, etc.)



### Example Applications
::: {.panel-tabset .panel-pills}

#### Polars


#### DuckDB
Outliers app: Reads and writes from DuckDB https://github.com/skaltman/outliers-app-db-python/blob/main/app.py
Database Explorer: https://shiny.posit.co/py/templates/database-explorer/

#### Pandas
AWS-Community-Builders-App: Process data from a CSV and displays it https://github.com/robertgv/aws-community-builders-dashboard

#### Sqlite3
Database monitoring app: https://github.com/posit-dev/py-shiny-templates/tree/main/monitor-database




