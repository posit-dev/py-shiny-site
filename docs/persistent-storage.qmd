---
title: Persistent storage & writing data
editor:
  markdown:
    wrap: sentence
lightbox:
  effect: fade
---

## What is persistent storage and when do we need it?

For our purposes, **persistent storage** is when we store data that persistes across sessions or browsers. In this article, we'll explore how to handle situations where your data is updated based on the actions of users.

For example, we may want to collect and display survey information from users. We could also have users entering data into a database through multiple platforms, including a shiny app, and want to ensure our dashboard is continuously displayed.

These situations entail both reading and writing to a data store that exists outside of a user's individual session.

If you're looking for how to work with data on a **read-only** basis, please refer to our other article [here](/docs/reading-data.qmd).

::: callout-note {collapse="true"}
### Authentication and Login Management
Authentication is a special case of collecting information from users to be used in an application. We're not going to talk about authentication or login management in this article and would highly recommend you look into integrations that handle this specifically.

If you're using Posit Connect, good news, we handle this for you! Your Connect admin should have more information for you on how authentication for your Connect

For others, we recommend checking out purpose-built integrations for authentication like:
* Auth0
Any others?

If you work for an organization with its own intranet or authentication system, they may also have preferences and/or tools for you to take into account.
:::


## Working with non-database stores (ex. Google Sheets, Object Stores)

```python
from shiny.express import ui, render, input
from shiny import reactive
import polars as pl
import gspread

gc = gspread.service_account(filename="../.config/gspread/service_account.json")
url = "https://docs.google.com/spreadsheets/d/166uMLi75GLD7eFUKe-vdKIpCk0EwbYWa2md4Zn9vJO4/edit?gid=0#gid=0"

sheet = gc.open_by_url(url)
# Set the worksheet you want to access based on the index here
worksheet = sheet.get_worksheet(0)
last_updated = None

with ui.sidebar():
    ui.input_text("name_input", "Enter your name:", placeholder="Your name here")
    ui.input_checkbox("checkbox", "I like checkboxes")
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50)
    ui.input_action_button("submit_button", "Submit")

flag = reactive.value(0)
df = reactive.value(
    pl.from_dicts(
        worksheet.get_all_records(expected_headers=["name", "checkbox", "number"]),
        schema={"name": pl.Utf8, "checkbox": pl.String, "number": pl.Int64},
    )
)


@reactive.effect
@reactive.event(input.submit_button)
def add_row():
    new_row = [input.name_input(), input.checkbox(), input.slider()]
    worksheet.append_row(new_row, insert_data_option="INSERT_ROWS")
    flag.set(1)


@reactive.effect
def refresh_data_if_dirty():
    if flag() == 1:
        df.set(
            pl.from_dicts(
                worksheet.get_all_records(),
                schema={"name": pl.Utf8, "checkbox": pl.String, "number": pl.Int64},
            )
        )
        print("Data is dirty, refreshing...")
        flag.set(0)


@render.data_frame
def show_results():
    return render.DataGrid(df())

```

This spreadsheet example is great for simple data collection, but there are a number of reasons why you may prefer another option. In the next example, we'll replace our Google Sheets workbook with a Postgres database. This gets us much closer to a traditional web application, with a persistent database for storage and all the standard database features like transaction locking, query optimization, and concurrency management.

## Working with Databases

### Reading from and writing to databases

We'll ground this initial example in an app that reads, writes, and updats the visualization based on a simple flag that tells us if the data is dirty or not.


::: {.panel-tabset .panel-pills}

#### Polars & Postgres
```{.python filename="setup.py"}
import polars as pl

# Don't store your creds in plain text, load them from a environment variables or a secrets manager
uri = "postgresql://postgres@localhost:5432/template1"

# Notice that this uses `read_*`. Polars cannot read the data lazily from the database, so this will load the entire query into memory.
def run_query(query):
    return pl.read_database_uri(query, uri)

```

```{.python filename="app.py"}
from shiny.express import ui, render, input, app_opts
from shiny import reactive
import polars as pl
import load_data

app_opts(debug=True)

full_query = "SELECT * FROM testapp"

with ui.sidebar():
    ui.input_text("name_input", "Enter your name:", placeholder="Your name here")
    ui.input_checkbox("checkbox", "I like checkboxes")
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50)
    ui.input_action_button("submit_button", "Submit")

# If this value is 1, our data is dirty, if it is 0, our data is clean
flag = reactive.value(0)
df = reactive.value(pl.LazyFrame(load_data.run_query(full_query)))


@reactive.effect
@reactive.event(input.submit_button)
def add_row():
    new_row = pl.DataFrame(
        {
            "name": input.name_input(),
            "checkbox": input.checkbox(),
            "favorite_number": input.slider(),
        }
    )
    new_row.write_database("testapp", load_data.uri, if_table_exists="append")

    # The table we're displaying no longer reflects the reality of the database because we just added a row, so we mark the data as dirty.
    flag.set(1)

    print("Added a new row!")


@reactive.effect
def refresh_data_if_dirty():
    if flag() == 1:
        df.set(pl.LazyFrame(load_data.run_query(full_query)))
        print("Data is dirty, refreshing...")
        # We set the flag back to 0 because we have just refreshed our data
        flag.set(0)


@render.data_frame
def show_results():
    return render.DataGrid(df().collect())

```
:::


Introduce the motivation for polling using the above example
Why polling?
* What if we have multiple users? Or a mixture of UI and database-based users? Or something that can updates the underlying data? If the user isn't the only one updating the data, our 'mark dirty on submit' logic isn't enough to keep the data up to date.
If you want to continuously check for changes to the data, polling is a much safer option.

### Reactive Polling

What is polling? When you use polling, every so often (based on an interval you set) Shiny will check with your database if there are any changes, based on a function you set. For example, you might have multiple applications inserting rows into a table. When a row is added, the count of rows changes, and the displayed data in the app needs to be updated to reflect this. See below for an example.

### App examples with polling
::: {.panel-tabset .panel-pills}

#### Polars + Postgres
```{.python filename="setup.py"}
import polars as pl

# Don't store your creds in plain text, load them from a environment variables or a secrets manager
uri = "postgresql://postgres@localhost:5432/template1"


# Notice that this uses `read_*`. Polars cannot read the data lazily from the database, so this will load the entire query into memory.
def run_query(query):
    return pl.read_database_uri(query, uri)
```

```{.python filename="app.py"}

from shiny.express import ui, render, input, app_opts
from shiny import reactive
import polars as pl
import setup

app_opts(debug=True)

full_query = "SELECT * FROM testapp"
starting_data = pl.LazyFrame(setup.run_query(full_query))

with ui.sidebar():
    ui.input_text("name_input", "Enter your name:", placeholder="Your name here")
    ui.input_checkbox("checkbox", "I like checkboxes")
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50)
    ui.input_action_button("submit_button", "Submit")


@reactive.effect
@reactive.event(input.submit_button)
def add_row():
    new_row = pl.DataFrame(
        {
            "name": input.name_input(),
            "checkbox": input.checkbox(),
            "favorite_number": input.slider(),
        }
    )
    new_row.write_database("testapp", setup.uri, if_table_exists="append")
    print("Added a new row!")


def num_rows():
    return load_data.run_query("SELECT COUNT(*) FROM testapp").item()


@reactive.poll(num_rows, 1)
def get_data():
    print("Checking for new data...")
    data = setup.update_data()
    return data


@render.data_frame
def show_results():
    return render.DataGrid(get_data())

```
:::





## Connecting to databases

### Example connecting with Ibis and saving to db with a form

## Deployment options

### Auth - connect callout

### SQL injection prevention
Callout near wherever we first execute SQL, be careful, diff libraries have tooling


### Connection pooling & transaction locking?

### Note on credentials? (don't use your admin creds in your app, have user creds for db, scope them narrowly, etc.)




