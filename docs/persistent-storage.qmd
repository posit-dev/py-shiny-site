---
title: Persistent storage & writing data
editor:
  markdown:
    wrap: sentence
lightbox:
  effect: fade
---

## What is persistent storage and when do we need it?

Shiny apps often need to read and write data. When we are displaying data and allowing users to interact with it, that is, allowing them **read-only** access, we can use the techniques in [Reading Data](/docs/reading-data.qmd). When we want to collect information from users, additional techniques are necessary.

In this article, we'll cover how to gather and **store** information from your users, as well as how to make sure your app displays those updates to users.

Let's start with a simple form-submission app. This application will

1. Collect information from users

2. Store their responses, and

3. Show all the information we've collected so far

We'll start from an app that doesn't save information beyond the Python session at all. In other words, if you refresh this app after submitting information, all the information will be gone and you'll be back to a blank slate once more.


```python
from shiny.express import ui, render, input
from shiny import reactive
import polars as pl


with ui.sidebar():
    ui.input_text("name_input", "Enter your name", placeholder="Your name here"),
    ui.input_checkbox("checkbox", "I like checkboxes"),
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50),
    ui.input_action_button("submit_button", "Submit"),

# This holds our data and is updated to reflect user submissions
# If we refresh the app, this goes back to the starting value (an empty dataframe)
data = reactive.value(
    pl.DataFrame(
        schema={
            "name": pl.Utf8,
            "checkbox": pl.Boolean,
            "favorite_number": pl.Int64,
        }
    )
)


@reactive.effect
@reactive.event(input.submit_button)
def results():
    row = {
        "name": input.name_input(),
        "checkbox": input.checkbox(),
        "favorite_number": input.slider(),
    }
    new_df = pl.concat([data.get(), pl.DataFrame(row)], how="vertical")
    data.set(new_df)


@render.data_frame
def show_results():
    return render.DataGrid(data())

```

Now, let's add in saving and loading our data. We'll start simple, with a CSV.

```{.python filename="setup.py"}
import polars as pl
from pathlib import Path

def load_data():
    return pl.read_csv(Path(__file__).parent / "saved_data.csv", has_header=True)

```

```{.python filename="app.py"}
from shiny.express import ui, render, input
from shiny import reactive
import polars as pl
import setup


with ui.sidebar():
    ui.input_text("name_input", "Enter your name", placeholder="Your name here"),
    ui.input_checkbox("checkbox", "I like checkboxes"),
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50),
    ui.input_action_button("submit_button", "Submit"),

data = reactive.value(setup.load_data())


@reactive.effect
@reactive.event(input.submit_button)
def results():
    row = {
        "name": input.name_input(),
        "checkbox": input.checkbox(),
        "favorite_number": input.slider(),
    }
    new_df = pl.concat([data.get(), pl.DataFrame(row)], how="vertical")
    data.set(new_df)
    data.get().write_csv("saved_data.csv")


@render.data_frame
def show_results():
    return render.DataGrid(data())

```

While this does work, it saves and loads the CSV from the file system from which the Python script is running. Frequently, we don't want to be reliant on running from the same machine or even the same server. In these cases, having our storage located in a remote location, be it Google Sheets, an object store like AWS S3, or a database, is very useful.

## Working with non-database data stores

Let's take this same application and build it with a Google Sheets integration. Google Sheets is frequently used as a collaboration tool and a way to collect survey results through different tools. We'll use the `gspread` package to integrate a simple Google Sheets connection into our application.

::: callout-note
### Google Sheets Integration
In the below example, we use `gspread` ([documentation](https://docs.gspread.org/en/latest/index.html)).
You'll need to follow their instructions for creating a service account in order to use the below code. Your organization may or may not support creating your own service account, so you may have to contact your IT department if you can't create one on your own.
:::


```python
from shiny.express import ui, render, input
from shiny import reactive
import polars as pl
import gspread

# Create variables for our service account info and the URL for our workbook
gc = gspread.service_account(filename="service_account.json")
url = "workbook_url"

sheet = gc.open_by_url(url)
# Set the worksheet you want to access based on the index here
worksheet = sheet.get_worksheet(0)

with ui.sidebar():
    ui.input_text("name_input", "Enter your name:", placeholder="Your name here")
    ui.input_checkbox("checkbox", "I like checkboxes")
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50)
    ui.input_action_button("submit_button", "Submit")

# Create a flag to mark when we need to update data
flag = reactive.value(0)
# Load the current data from the worksheet
df = reactive.value(
    pl.from_dicts(
        worksheet.get_all_records(expected_headers=["name", "checkbox", "number"]),
        schema={"name": pl.Utf8, "checkbox": pl.String, "number": pl.Int64},
    )
)


@reactive.effect
@reactive.event(input.submit_button)
def add_row():
    new_row = [input.name_input(), input.checkbox(), input.slider()]
    worksheet.append_row(new_row, insert_data_option="INSERT_ROWS")
    # Set the dirty data flag to 1 because we know we've just inserted
    # new values into the worksheet that aren't currently reflected
    flag.set(1)


@reactive.effect
def refresh_data_if_dirty():
    if flag() == 1:
        # Set our data reactive value to the current worksheet contents
        df.set(
            pl.from_dicts(
                worksheet.get_all_records(),
                schema={"name": pl.Utf8, "checkbox": pl.String, "number": pl.Int64},
            )
        )
        # Set the dirty data flag back to 0 because our data should now be refreshed
        flag.set(0)


@render.data_frame
def show_results():
    return render.DataGrid(df())

```

This spreadsheet example is great for simple data collection, but there are a number of reasons why you may prefer another option (ex. concurrency management, larger data, more secure storage, etc.)
In the next example, we'll replace our Google Sheets workbook with a Postgres database. This gets us much closer to a traditional web application, with a persistent database for storage and all the standard database features like transaction locking, query optimization, and concurrency management.

## Working with Databases

### Reading from and writing to databases

We'll ground this initial example in an app that reads, writes, and updates the visualization based on a simple flag that tells us if the data is dirty or not.


::: {.panel-tabset .panel-pills}
#### Polars & Postgres
```{.python filename="setup.py"}
import polars as pl

# Don't store your creds in plain text, load them from a environment variables
# or a secrets manager
uri = "postgresql://postgres@localhost:5432/template1"

# Notice that this uses `read_*`. Polars cannot read the data lazily from the database,
# so this will load the entire query into memory.
def run_query(query):
    return pl.read_database_uri(query, uri)

```

```{.python filename="app.py"}
from shiny.express import ui, render, input, app_opts
from shiny import reactive
import polars as pl
import load_data

app_opts(debug=True)

full_query = "SELECT * FROM testapp"

with ui.sidebar():
    ui.input_text("name_input", "Enter your name:", placeholder="Your name here")
    ui.input_checkbox("checkbox", "I like checkboxes")
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50)
    ui.input_action_button("submit_button", "Submit")

# If this value is 1, our data is dirty, if it is 0, our data is clean
flag = reactive.value(0)
df = reactive.value(pl.LazyFrame(load_data.run_query(full_query)))


@reactive.effect
@reactive.event(input.submit_button)
def add_row():
    new_row = pl.DataFrame(
        {
            "name": input.name_input(),
            "checkbox": input.checkbox(),
            "favorite_number": input.slider(),
        }
    )
    new_row.write_database("testapp", load_data.uri, if_table_exists="append")

    # The table we're displaying no longer reflects the reality of the database
    # because we just added a row, so we mark the data as dirty.
    flag.set(1)

    print("Added a new row!")


@reactive.effect
def refresh_data_if_dirty():
    if flag() == 1:
        df.set(pl.LazyFrame(load_data.run_query(full_query)))
        print("Data is dirty, refreshing...")
        # We set the flag back to 0 because we have just refreshed our data
        flag.set(0)


@render.data_frame
def show_results():
    return render.DataGrid(df().collect())

```

#### Ibis & Postgres

```python
from shiny.express import ui, render, input, app_opts
from shiny import reactive
import ibis
import pandas as pd

app_opts(debug=True)

con = ibis.postgres.connect(
    user="postgres", password="", host="localhost", port=5432, database="template1"
)
df = con.table("testapp")

with ui.sidebar():
    ui.input_text("name_input", "Enter your name:", placeholder="Your name here")
    ui.input_checkbox("checkbox", "I like checkboxes")
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50)
    ui.input_action_button("submit_button", "Submit")

# If this value is 1, our data is dirty, if it is 0, our data is clean
flag = reactive.value(0)
data = reactive.value(df.to_pandas())


@reactive.effect
@reactive.event(input.submit_button)
def add_row():
    new_row = pd.DataFrame.from_records(
        [
            {
                "name": input.name_input(),
                "checkbox": input.checkbox(),
                "favorite_number": input.slider(),
            }
        ]
    )
    con.insert("testapp", new_row, overwrite=False)
    flag.set(1)
    print("Added a new row!")


@reactive.effect
def refresh_data_if_dirty():
    if flag() == 1:
        data.set(df.to_pandas())
        print("Data is dirty, refreshing...")
        flag.set(0)


@render.data_frame
def show_results():
    return render.DataGrid(data())
```

:::

While managing a flag with this scale of app isn't too bad, you can imagine it would get complicated if there are lots of different things in and out of the Shiny app that might lead the displayed data to be out of date.

To help with this sort of problem, Shiny provides tools for **polling**, that is, checking in with the data source for changes at a specified interval. We'll take our application and simplify it with polling in the next example.

### Reactive Polling

What is polling? When you use polling, every so often (based on an interval you set) Shiny will check with your database if there are any changes, based on a function you set.

For example, you might have multiple applications inserting rows into a table. When a row is added, the count of rows changes, and the displayed data in the app needs to be updated to reflect this.

See below for an example.

### App examples with polling
::: {.panel-tabset .panel-pills}

#### Polars + Postgres
```{.python filename="setup.py"}
import polars as pl

# Don't store your creds in plain text,
# load them from a environment variables or a secrets manager
uri = "postgresql://postgres@localhost:5432/template1"


# Notice that this uses `read_*`. Polars cannot read the data lazily from the database,
# so this will load the entire query into memory.
def run_query(query):
    return pl.read_database_uri(query, uri)
```

```{.python filename="app.py"}

from shiny.express import ui, render, input, app_opts
from shiny import reactive
import polars as pl
import setup

app_opts(debug=True)

full_query = "SELECT * FROM testapp"

with ui.sidebar():
    ui.input_text("name_input", "Enter your name:", placeholder="Your name here")
    ui.input_checkbox("checkbox", "I like checkboxes")
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50)
    ui.input_action_button("submit_button", "Submit")


@reactive.effect
@reactive.event(input.submit_button)
def add_row():
    new_row = pl.DataFrame(
        {
            "name": input.name_input(),
            "checkbox": input.checkbox(),
            "favorite_number": input.slider(),
        }
    )
    new_row.write_database("testapp", setup.uri, if_table_exists="append")
    print("Added a new row!")


def num_rows():
    return setup.run_query("SELECT COUNT(*) FROM testapp").item()


@reactive.poll(num_rows, 1)
def get_data():
    print("Checking for new data...")
    data = setup.run_query()
    return data


@render.data_frame
def show_results():
    return render.DataGrid(get_data())

```

#### Ibis + Postgres
```python
from shiny.express import ui, render, input, app_opts
from shiny import reactive
import pandas as pd
import ibis

app_opts(debug=True)

con = ibis.postgres.connect(
    user="", password="", host="", port=, database=""
)
df = con.table("yourTable")

with ui.sidebar():
    ui.input_text("name_input", "Enter your name:", placeholder="Your name here")
    ui.input_checkbox("checkbox", "I like checkboxes")
    ui.input_slider("slider", "My favorite number is:", min=0, max=100, value=50)
    ui.input_action_button("submit_button", "Submit")


@reactive.effect
@reactive.event(input.submit_button)
def add_row():
    new_row = pd.DataFrame.from_records(
        [
            {
                "name": input.name_input(),
                "checkbox": input.checkbox(),
                "favorite_number": input.slider(),
            }
        ]
    )
    con.insert("testapp", new_row, overwrite=False)
    print("Added a new row!")


def num_rows():
    return df.count().execute()


@reactive.poll(num_rows, 1)
def get_data():
    print("Checking for new data...")
    return df.to_pandas()


@render.data_frame
def show_results():
    return render.DataGrid(get_data())

```
:::


## Getting ready for production


::: {.callout-note collapse="true"}
### With Posit Connect Cloud or Posit Connect

As a developer, Posit Connect and Posit Connect Cloud allow you to publish Shiny apps with fine-grained access. You can choose to give individuals and groups of users collaborator permissions, view-only, or keep your applications private.

Your Connect administrator can control app access through standard Single Sign-On (SSO) tools or custom controls.

Connect also provides secrets-management tools for your database credentials and can access other data sources through [Pins](https://rstudio.github.io/pins-python/). See more about how Posit Connect facilitates connections to data sources [here](https://solutions.posit.co/connections/deploying-data/).

You can try Connect Cloud for free [here](https://connect.posit.cloud/) assuming your app can be hosted publicly.

:::

::: {.callout-note collapse="true"}
### On your own
You might notice we're getting closer and closer to a standard, full-stack web application as we move through this article.
As you add features like database connections and saved user-inputs, there are additional considerations to opening up usage of your application.

#### Authentication
Authentication is a special case of collecting information from users to be used in an application. There are additional security considerations to take into account when storing usernames and passwords.

If you're using Posit Connect, good news, we handle this for you! Your Connect admin should have more information for you on how authentication for your Connect instance is handled and how to restrict access to your application.

For others, we recommend checking out purpose-built integrations for authentication. If you work for an organization with its own intranet or authentication system, they may also have preferences and/or tools for you to take into account.

#### Database credentials
It's best not to use your own, personal credentials and instead have a specific user account or service account just for app usage. Ask your database administrator for appropriately scoped credentials for your use case.
If that's you, think about what you want users to be able to do (read, read and write) and consult the documentation for your database system.

#### SQL injection protection
Allowing users to read and write from a database, particularly using SQL, opens up a potential vector for attackers.
Follow commonly accepted best practices for avoiding SQL injection attacks like using prepared statements or object mappings (like Ibis provides) instead of string concatenation.

:::

