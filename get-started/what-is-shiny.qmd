---
title: What is Shiny?
---

```{=html}
<style>
  .btn-links {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    justify-content: center;
  }

  .btn-link-large {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 150px;
    height: 150px;
    font-size: 1.5rem;
    border: 1px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    padding: 1.25rem;
    text-decoration: none;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  }

  .btn-link-large i {
    margin-top: 10px;
    font-size: 2rem;
  }

  .btn-link-large:hover {
    text-decoration: none;
    border: 1px solid var(--bs-primary);
  }
</style>
```

Whether youâ€™re a data scientist, analyst, or developer, Shiny makes it easy to [create](create-run.qmd) rich, [interactive experiences](/docs/ui-overview.qmd) in pure Python with a fully [reactive framework](/docs/reactive-foundations.qmd).
No need to learn JavaScript or front-end frameworks.

## Batteries included {#batteries-included}

Shiny for Python comes fully equipped with everything you need to build a dashboard right out of the box, including a rich set of [input](/components/#inputs) and [output](/components/#outputs) components.
There is an entire [components gallery](/components/) to help you quickly build interactive applications.

[Layout](/layouts/) options let you organize your UI efficiently, while built-in [theming](/docs/ui-customize.qmd) (including [dark mode](/components/inputs/dark-mode)) ensures your app looks great with minimal effort.

Already have a brand guideline?
You can use [brand.yml](https://posit-dev.github.io/brand-yml/) to apply consistent branding, colors, and logos across your application.

<div class="btn-links">
  <a href="/components#inputs" class="btn-link-large">
    Inputs
    <i class="bi bi-sliders primary" role="img" aria-hidden="true"></i>
  </a>

  <a href="/components#outputs" class="btn-link-large">
    Outputs
    <i class="bi bi-bar-chart-line-fill primary" role="img" aria-hidden="true"></i>
  </a>

  <a  href="/layouts" class="btn-link-large">
    Layouts
    <i class="bi bi-layout-text-window-reverse primary" role="img" aria-hidden="true"></i>
  </a>
</div>

## Reactivity {#reactivity}

At the heart of Shiny is [reactivity](/docs/reactive-foundations.qmd), a system that automatically updates [outputs](/components/#outputs) when [inputs](/components/#inputs) change for seamless interactivity, without callbacks.

Shiny's reactive engine avoids unnecessary computations by only re-calculating the outputs whose inputs have changed, making Shiny ideal for fast data-driven applications, enabling live updates for [charts, tables](/components/#outputs), and [reports](https://quarto.org/docs/interactive/shiny/) with minimal effort.

Below is a Shiny application where you have the output text react to _both_ input slider values
and the second row of text _only_ reacts to the first slider value.

```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]
#| layout: vertical
#| viewerHeight: 250

from shiny import reactive
from shiny.express import ui, render, input

# input slider 1
ui.input_slider("slider1", "Slider 1", min=1, max=50, value=20)

# input slider 2
ui.input_slider("slider2", "Slider 2", min=1, max=50, value=40)

# output reacts to both sliders
@render.text
def both_sliders_output():
    return f"You have set Slider 1: {input.slider1()}, Slider 2: {input.slider2()}"

# output that only reacts to slider 1
@render.text
def result():
    return f"The value for slider 1 squared: {input.slider1()**2}."
```

## Jumpstart with templates {#templates}

Below is a full Shiny application in action, complete with [reactivity](/docs/reactive-foundations.qmd) and a [user interface](/docs/ui-overview.qmd)!

::::: {.column-screen-inset}
::: {.hello-output}
<iframe
  src="https://gallery.shinyapps.io/template-dashboard/"
  frameborder="0"
  width="100%"
  class="mb-0 card hello-output-iframe"
></iframe>

<style>
  .hello-output-iframe {
    height: 700px;
  }
@media only screen and (max-width: 611px) {
  .hello-output-iframe {
    height: 2125px;
  }
}
</style>
:::
:::::

Hit the ground running with one of our [starter templates](/templates/), like the app above, by using `shiny create`.

There are templates for common use cases.
For example, [data dashboards](templates/dashboard/), [applications](/templates/database-explorer/), [streaming](/templates/monitor-database/) updates, or [data entry](/templates/survey/).

Use the terminal command below to [create and run](create-run.qmd) your first application from a [template](/templates/).

```bash
shiny create --template dashboard
```


## Extensibility {#extensible}

While Shiny includes everything you need to build an app, is built on a foundation of web standards, making it highly [extensible](/docs/).

If you need a [custom component](/docs/custom-components-pkg) or [user interface](/docs/ui-customize), you can incrementally integrate [JavaScript](/docs/custom-component-one-off), [HTML](/docs/ui-html.html), or even WebAssembly without having to learn complicated build tooling and frameworks.

The Python inputs return regular HTML:

```python
>>> from shiny import ui
>>> ui.input_action_button("btn", "Button")
```

```html
<button class="btn btn-default action-button" id="btn" type="button">Button</button>
```

If you're versed in web programming, you can also use Shiny to create [custom components](/docs/custom-component-one-off.qmd) that leverage your favorite JavaScript framework from Python.

## Install, create, and run

Now that you know a little more about Shiny for Python,
let's go [install Shiny](install.qmd) so you can [create your first application](create-run.qmd)!
